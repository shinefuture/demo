# shell变量

变量可分为：环境变量（全局变量）、普通变量和局部变量  
 - 环境变量可以在创建它们的shell及其派生出来的任意子进程shell中使用；  
   环境变量又可以分为自定义环境变量和bash内置的环境变量
 - 普遍变量只能在创建它们的shell函数或shell脚本中使用  
 - 局部变量只在函数内使用  

## 1 环境变量

### 1.1 环境变量配置文件

配置文件 | 说明
---|---
/etc/profile | 用户登录时加载，适用于所有用户
/etc/bashrc | 用户登录以及远程登录、bash子shell进入时加载，适用于所有用户
HOME/.bash_profile | 用户登录时加载，只适用于当前用户
HOME/.bash_rc | 用户登录以及远程登录、bash子shell进入时加载，只适用于当前用户

### 1.2 常见系统环境变量

常见系统环境变量：

环境变量 | 用途
---|---
HOME | 当前用户家目录
PATH | 命令执行时的搜索路径
SHELL | 当前shell解析的命令
BASH | 调用bash实例时使用的全路径名
LANG | 当前系统语言环境，常设置为en\_US.UTF-8或zh\_CN.UTF-8
UID | 当前用户ID
GROUPS | 当前用户所属的组
PPID | 父进程的进程ID
USER | 当前用户的用户名
PWD | 记录当前目录
OLDPWD | 记录之前的目录，用于"-"符号
HISTFILE | 记录history命令记录文件的位置
HISTFILESIZE | 设置HISTFILE文件记录命令的行数
HISTSIZE | 命令缓冲区大小；在命令缓冲区满或退出shell时才将缓冲区的记录写入到HISTFILE文件中
HOSTNAME | 展示主机名
HOSTTYPE | 主机架构，如i386、i686等
MACHTYPE | 主机类型的GNU标识，一般为"主机架构-公司-系统-gnu"格式
PS1 | 命令提示符，默认为[\u@\h \W]\$
BASH_ENV | 一般为空。如果该变量在调用脚本时已经设置，它的值将被展开，并用作在执行脚本前读取的启动文件名，**临时设置后需export**
BASH_VERSINFO | 一个只读变量数组，保存bash的版本信息
TMOUT | 作为内建命令read的默认超时时间。当shell出于交互状态时，这个值表示等待在基本提示串后输入的秒数
SHLVL | 每新增一个shell，该值就增加1
RANDOM | 生成一个0\~32767的随机整数

### 1.3 查看变量的值

有3个命令：
- set  
  输出所有的变量和函数，包括全局变量和局部变量  
- env
  只显示全局变量  
- declare
  输出所有的变量、函数、整数和已经导出的变量，与set差异不大  

### 1.4 变量定义

变量命名必须以字母或下划线开头，后面可以跟数字、字母和下划线，变量长度没有限制。  
按照系统规范，所有**环境变量的名字均采用大写形式**。

#### 1.4.1 自定义环境变量

1. 设置环境变量  

**使用export或者declare进行设置：**
  - export 变量名=value
  - 变量名=value ; export 变量名
  - declare -x 变量名=value  
注意：此种方法设置的环境变量只是临时生效，只在当前shell以及子shell中有效；当退出当前shell时，会失效。  

**环境变量永久生效的常用配置文件：**
  - 用户的环境变量配置  
  家目录下的~/.bashrc，以及~/.bash_profile，推荐优先在~/.bashrc中进行设置  
  - 全局环境变量配置  
  /etc/profile、/etc/bashrc、/etc/profile.d/  
  推荐优先在/etc/bashrc中进行设置，次之/etc/profile

2. 设置登录提示的两种方式
  - 在/etc/motd中增加提示字符串  
  - 在/etc/profile.d/增加echo脚本，登录时会自动将此目录下所有脚本执行一遍。  

#### 1.4.2 显示与取消环境变量

1. 通过echo或printf命令打印环境变量
```
wxm@server:~$ echo $HOME
/home/wxm
wxm@server:~$ printf "$HOME\n"
/home/wxm
```
2. 用env或set显示默认的环境变量
此种方法，显示内容过多，不易辨别。  

3. 用unset取消本地变量和环境变量
```
wxm@server:~$ echo $HOME
/home/wxm
wxm@server:~$ unset HOME
wxm@server:/home/wxm$ echo $HOME
  //<-空
wxm@server:/home/wxm$
```
注意，unset只在当前shell及子shell起作用，父目录中对应的变量不变。  

## 2 普通变量

普通变量只在当前shell生存期的脚本中使用。 

1. 有以下3种定义方法：
   - 变量名=value  
  值里有变量的会被解析后再输出。  
  当内容为简单连续的数字、字符串、路径名时，可以这样使用。  
   - 变量名='value'  
  单引号里有什么就输出什么，所见即所得，即使内容有变量和命令，也不会执行，而是原样输出。  
  只适合于纯字符串。  
   - 变量名="value"  
  输出变量内容时，引号里的变量及命令会经过解析后再输出内容。  
  适合于字符串中附带有变量及命令且想将其解析后再输出的变量定义。  
   - 总结：  
  数字不加引号，其他默认加双引号。  
  当变量名后面连接有其他字符时，必须给变量加上大括号{}，如$dbname\_tname需要改成${dbname}\_tname。  

2. 把一个命令的结果作为变量的内容赋值方法  
   - 变量名=\`ls\` #<==把命令用反引号引起来  
   - 变量名=$(ls)  #<==把命令用$()引起来，推荐此种方法  


## 3 特殊变量

### 3.1 特殊位置参数变量

特殊位置参数变量：
  - $0   获取当前执行的Shell脚本的文件名，如果执行脚本包含了路径，那么就包括脚本路径  
  - $n   获取当前执行的shell脚本的第n个参数，如果n大于9，则用大括号括起来，如${10}  
  - $#   获取当前执行的shell脚本后面接的参数的总个数  
  - $\*   获取当前shell脚本所有传参的参数，如果加上双引号，即"$\*"，则表示将所有的参数视为单个字符串，相当于"$1 $2 $3"  
  - $@   获取当前shell脚本所有传参的参数，如果加上双引号，即"$@"，则表示将所有的参数视为不同的独立字符串，相当于"$1" "$2" "$3"   "..."；这是将多参数传递给其他程序的最佳方式。  
注意：$*与$@不加引号时，作用相同；加上引号时，作用不同。  

### 3.2 特殊状态变量

特殊状态变量：
  - $?  获取执行上一个命令的执行状态返回值(0为成功，非零为失败)  
  - $$  获取当前执行的shell脚本的进程号(PID)  
  - $!  获取上一个在后台工作的进程的进程号  
  - $_  获取在此之前执行的命令或脚本的最后一个参数  

$?返回值参考：
 - 0 表示运行成功  
 - 2 权限拒绝  
 - 1~125 表示运行失败，脚本命令、系统命令错误或参数传递错误  
 - 126 找到该命令了，但是无法执行  
 - 127 未找到要运行的命令  
 - 大于128 命令被系统强制结束  

## 4 数组

使用数组的典型场景是一次性要记录很多类型相同的数据；但不是说类型一定要相同，因为shell变量时弱类型的，并不要求数组的每个元素都是相同类型。  
shell数组对元素个数没有限制，但只支持一维数组。  

### 4.1 定义  

  - 静态数组：array=(1 2 3)  
  - 动态数组：array=($(ls))  
  - 也可以用declare命令定义数组：  
    ``declare -a Array``  
    ``declare -a Array=(0 1 2)``  
  - 还可以给特定的元素赋值：  
    ``score=([3]=3 [5]=5 [7]=7) ``

### 4.2 数组操作  

1. 数组取值    
   - 取出单个元素：${array[index]}, index是数组下标
   - 取出所有元素：${array[*]}或${array[@]}  
注：${array[@]}得到的是以空格隔开的元素值，而${array[*]}的输出是一整个字符串  
  
2. 数组长度  
  ${#array[*]}或${#array[@]}   
3. 数组截取  
   - 取出数组的第一、二个元素   
   `` echo ${array[@]:1:2}``  
   - 取出第二个元素从第0个字符开始连续5个字符  
   ``echo ${array[2]:0:5}``  
4. 连接数组  
  ``conn=(${array1[@]} $array2[@])``  
5. 替换元素  
  ``array=(${array[@]/src/dest})``  
6. 取消数组或元素  
  ``unset array[1]``  
  ``unset array``  

2. 打印  
  - 打印所有元素：${array[*]}或${array[@]}  
  - 打印数组长度：${#array[*]}或${#array[@]}  
  - 打印单个元素：${array[i]}  i是数组下标  
注：${array[@]}得到的是以空格隔开的元素值，而${array[*]}的输出是一整个字符串

## 5 只读变量  

只读变量又称常量，是通过readonly内建命令创建的变量，声明时赋值，无法修改。  
定义：  
``readonly RO=100 ``  

## 6 变量的作用域  

以下情况不包含unset取消变量情况，一旦变量unset后，马上无效。

1. 临时设置的环境变量
即使用export或declare -x配置的变量  
作用域： 当前shell及子shell，退出当前shell后失效。

2. 永久设置的环境变量  
即在/etc/profile、/etc/bashrc、HOME/.bashrc、HOME/.bash_profile中配置的变量  
作用域：一直有效  

3. 普通变量  
即未使用任何标识定义的变量  
作用域：只在当前shell有效  


4. 局部变量  
在函数体内使用local标识的变量，例``local VAR=100``  
作用域：只在函数体内有效  


